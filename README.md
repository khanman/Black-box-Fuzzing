## Black-box Fuzzing

## The design of your test harness:

To fuzz the target program, a test harness was designed that can run the program on an different input and collect any resulting crash dump for later analysis. That is, my harness should be able to execute a target program in a child process, by using the subprocess cmd from the python library to monitor the child for abnormal termination, and in that case store the childâ€™s core dump.

Code to Child Process:
process = subprocess.Popen([app, fuzz_output],stdout=subprocess.PIPE,stderr=subprocess.PIPE)

the fuzzer takes init_config_value and input seed, the pdf file is taken in a byte array and it is index and a small protion say 1% or 2% or more of the file is taken and bits are flipped. Making use of random.seed from python library to make sure Input generation should be deterministic given an initial configuration value; that is, two fuzzing runs with a given configuration value should produce identical sequences of mutated inputs.   

## The input generation strategy you used

Random.seed() is used to make sure mutant input from the input seed located is generated taking randomly and flipping bits by xor and write the byte array and passed the new pdf file as input to pdftotext as subprocess to generate dumps.Randomly changing bits and generating dumps.

## The criteria you used to cluster your crash dumps

Implemented a Logger which writes the Init_config_value and and core dump file name which is generated into a text file the text file is given as input to cluster.py script. The script reads the file line by line and grabs the core file name and passed to the following cmd 
gdb pdftotext -batch -ex 'core-file $filename' -ex 'bt' i am looping over all the core files by running the above cmd and looking for segmentation fault followed at what location. Clustering based on the address, one with same address and different configuration are clustered into one.Clustered the crash dumps my fuzzer produced, grouped crashes according to whether they represent the same bug in the target program.Did a gdb for all the core files and extracted the required information to cluster the errors. Cluster.py contains the script to do the above it takes a log file generated as a input from the cmd line.

Example of log file:
$init_config_value $core-file

## How many bugs did you find, and of what kind?
Found only one bug,
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffff7acc75b in XRef::getNumEntry(long long) () from /usr/lib/x86_64-linux-gnu/libpoppler.so.44

# bt
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `/usr/bin/pdftotext mutate.pdf'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffff7acc75b in XRef::getNumEntry(long long) () from /usr/lib/x86_64-linux-gnu/libpoppler.so.44
#0  0x00007ffff7acc75b in XRef::getNumEntry(long long) () from /usr/lib/x86_64-linux-gnu/libpoppler.so.44
#1  0x00007ffff7aaca0e in Lexer::getObj(Object*, char const*, int) () from /usr/lib/x86_64-linux-gnu/libpoppler.so.44
#2  0x00007ffff7ab71ce in Parser::makeStream(Object*, unsigned char*, CryptAlgorithm, int, int, int, int, bool) () from /usr/lib/x86_64-linux-gnu/libpoppler.so.44
#3  0x00007ffff7ab78a8 in Parser::getObj(Object*, bool, unsigned char*, CryptAlgorithm, int, int, int, int, bool) () from /usr/lib/x86_64-linux-gnu/libpoppler.so.44
#4  0x00007ffff7acb2ec in XRef::readXRef(long long*, std::vector<long long, std::allocator<long long> >*, std::vector<int, std::allocator<int> >*) () from /usr/lib/x86_64-linux-gnu/libpoppler.so.44
#5  0x00007ffff7acb509 in XRef::XRef(BaseStream*, long long, long long, bool*, bool) () from /usr/lib/x86_64-linux-gnu/libpoppler.so.44
#6  0x00007ffff7abb53f in PDFDoc::setup(GooString*, GooString*) () from /usr/lib/x86_64-linux-gnu/libpoppler.so.44
#7  0x00007ffff7abb768 in PDFDoc::PDFDoc(GooString*, GooString*, GooString*, void*) () from /usr/lib/x86_64-linux-gnu/libpoppler.so.44
#8  0x00007ffff7ab0055 in LocalPDFDocBuilder::buildPDFDoc(GooString const&, GooString*, GooString*, void*) () from /usr/lib/x86_64-linux-gnu/libpoppler.so.44#9  0x0000555555556a47 in ?? ()
#10 0x00007ffff72d6ec5 in __libc_start_main (main=0x555555556730, argc=2, argv=0x7fffffffec28, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffec18) at libc-start.c:287
#11 0x00005555555576cd in ?? ()

## Which bugs were easier to trigger, which were more difficult, and why?

Its easier to trigger segmentation fault all the dumps generated preoduced the same. I ran over 20000 tests all produced the same bug. As, changing few bits in the file casues it to terminte the program. Abort bugs are difficult to find need to have better spread and randomize the pdf.




## Crash Triage
Instructions to run fuzzer/cluster.py $core-file.txt

After exceution of:
./fuzz $init_config_value $input_seed 
a core_file.txt is generated pass the core_file.txt as a input to cluster.py which will analyze and cluster common bugs and return a json. 

o/p of Cluster.py:
{
    "clusters": [
        [
            <init_config_value_0>,
            <init_config_value_1>,
            <init_config_value_2>,
            // ...
        ],
        // additional clusters of initial configuration values
    ]

}
## Testing
Over 20000 tests and around 900 core dumps 
